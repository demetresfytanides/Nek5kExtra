c-----------------------------------------------------------------------
      subroutine uservp(i,j,k,eg) ! set variable properties
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer i,j,k,e,eg
     
c     e = gllel(eg)

      udiff  = 0.0
      utrans = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userf(i,j,k,eg) ! set acceleration term
c
c     Note: this is an acceleration term, NOT a force!
c     Thus, ffx will subsequently be multiplied by rho(x,t).
c
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      common /myforce/ fxx(lx1,ly1,lz1,lelt)
     $               , fyy(lx1,ly1,lz1,lelt)
     $               , fzz(lx1,ly1,lz1,lelt)

      integer i,j,k,e,eg

      e = gllel(eg)

      ffx = fxx(i,j,k,e)
      ffy = fyy(i,j,k,e)
      ffz = fzz(i,j,k,e) 
          !-9.81*(temp/283.15+0.608*ps(1))


      return
      end
c-----------------------------------------------------------------------
      subroutine userq(i,j,k,eg) ! set source term
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer i,j,k,e,eg

c     e = gllel(eg)

      qvol   = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc(i,j,k,f,eg) ! set up boundary conditions
c     NOTE ::: This routine MAY NOT be called by every process
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer i,j,k,f,e,eg

c     if (cbc(f,gllel(eg),ifield).eq.'v01')

      ux   = 0.0
      uy   = 0.0
      uz   = 0.0
      temp = 0.0


      return
      end
c-----------------------------------------------------------------------
      subroutine useric(i,j,k,eg) ! set up initial conditions
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer i,j,k,e,eg



      real amp,big

      ie = gllel(ieg)
       amp=1.0*sqrt(0.5e-3*2/3)

       big =1.e7*eg+1.e8*i+1.e9*j+1.e10*k
       big1 =2*pi*x/0.1
       big2 =2*pi*y/0.1
       big3 =2*pi*z/0.1
       rand1 = cos(big1)*sin(big2)*sin(big3)
       rand2 = cos(rand1*big1)*sin(big2)*sin(big3)
       rand3 = cos(rand2*big1)*sin(big2)*sin(big3)

       ux =sin(2*pi*x/0.1)*
     $   sin(2*pi*y/0.1)*sin(2*pi*z/0.1)



c         rand1
       uy = 0 ! amp*rand2
       uz = 0 ! amp*rand3
c      if (nid.eq.0) write(6,*)'check init', i,j,k,ux,uy,uz


       amp=1.0

       temp = 283.15 +rand2*amp
      amp=0.001
      if(ifield.eq.3) then
      temp=0.007644+rand*amp!   0.0061562!6.15e-03
      endif



      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      real vxa, vya, vza, vx2,xy2,xz2
      real tkeota, A,a1, te2, epss
      real Tmax, Tmin, psmax, psmin
      parameter (lt=lx1*ly1*lz1*lelt)

      common /myTKE1/dis1(lt)

      nt  = nx1*ny1*nz1*nelt
      if (istep.eq.0)  call prepost (.true.,'   ')

      Tmin = 0.
      Tmax = 350.0
      psmin = 0.
      psmax = 1.0

         do i=1, n
            t(i,1,1,1,1)=min(Tmax, t(i,1,1,1,1))
            t(i,1,1,1,1)=max(Tmin, t(i,1,1,1,1))

            t(i,1,1,1,2)=min(psmax, t(i,1,1,1,2))
            t(i,1,1,1,2)=max(psmin, t(i,1,1,1,2))
         enddo

c     call hpts()

      vxa = glsc2(vx,   bm1,nt) / volvm1        ! volume-average
      vya = glsc2(vy,   bm1,nt) / volvm1
      vza = glsc2(vz,   bm1,nt) / volvm1
      vx2 = glsc3(vx,vx,bm1,nt) / volvm1
      vy2 = glsc3(vy,vy,bm1,nt) / volvm1
      vz2 = glsc3(vz,vz,bm1,nt) / volvm1

      te2 = glsc2(t ,bm1,nt) / volvm1
      !vx2 = vx2 - vxa*vxa !redundant but ensures isotropy
      !vy2 = vy2 - vya*vya
      !vz2 = vz2 - vza*vza
      !if (vx2.gt.0.) vx2 = sqrt(vx2)            ! volume-rms
      !if (vy2.gt.0.) vy2 = sqrt(vy2)
      !if (vz2.gt.0.) vz2 = sqrt(vz2)
      tketa = 0.5*(vx2+vy2+vz2) !tke(t)
      if(nid.eq.0) write(*,*) 'tke_t=', tketa
      if(nid.eq.0) write(*,*) "Tmean=", te2
      ifxyo=.true.
      do i=1,nt
      x = xm1(i,1,1,1)
      y = ym1(i,1,1,1)
      z = zm1(i,1,1,1)
      vx(i,1,1,1)=sin(2*pi*x/.1)*sin(2*pi*y/.1)*sin(2*pi*z/.1)
c     $      *sin(2*pi*y/0.1)*sin(2*pi*z/0.1)
      vy(i,1,1,1) = 0
      vz(i,1,1,1) = 0
      enddo
      call outpost(vx,vy,vz,pr,t,'chk')
      call my_forcing


      call my_diss

      epss = glsc2(dis1, bm1,nt) / volvm1

      if(nid.eq.0) write(*,*) "epsilon = ", epss
      return
      end
c-----------------------------------------------------------------------
      subroutine userqtl ! Set thermal divergence

      call userqtl_scig

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat   ! This routine to modify element vertices
      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'

      common /mygeom/ xmn,xmx,ymn,ymx,zmn,zmx

      real xlen, ylen, zlen

      common /nekmpi/ mid,mp,nekcomm,nekgroup,nekreal

      integer icalld
      save    icalld
      data    icalld /0/

      call domain_size(xmn,xmx,ymn,ymx,zmn,zmx)

      xlen = xmx-xmn
      ylen = ymx-ymn
      zlen = zmx-zmn
      return
      end
c-----------------------------------------------------------------------
      subroutine my_forcing
      include 'SIZE'
      include 'TOTAL'

      common /mygeom/ xmn,xmx,ymn,ymx,zmn,zmx
      common /myforce/ fxx(lx1,ly1,lz1,lelt)
     $               , fyy(lx1,ly1,lz1,lelt)
     $               , fzz(lx1,ly1,lz1,lelt)

      common /myuhat/  ucs(2,2,2,8),vcs(2,2,2,8),wcs(2,2,2,8)
     $               , work(64),cs(8)
      common /mynorm/  uuu(2,2,2,8),vvv(2,2,2,8),www(2,2,2,8)

      real xlen, ylen, zlen
      real eps, argx, argy, argz, cx, cy, cz
      real sx, sy, sz, x, y,z, u,v,w,b
      real utot,utot_inv
      integer icalld
      save    icalld
      data    icalld /0/

      if (icalld.eq.0) call domain_size(xmn,xmx,ymn,ymx,zmn,zmx)
      icalld = 1

      xlen = xmx-xmn
      ylen = ymx-ymn
      zlen = zmx-zmn

      n = lx1*ly1*lz1*nelv

      eps =1.0 ! 0.003375!1.9/100./100.

      !call rzero(ush,8*12) ! Zero the myuhat common block

      call   rzero(ucs, 8*12)
      call   rzero(vcs, 8*12)
      call   rzero(wcs, 8*12)

      do kz=1,2  ! Find uhat = \int sin(kx 2pi x) ux
      do ky=1,2
      do kx=1,2

         do i=1,n

            x=xm1(i,1,1,1)
            y=ym1(i,1,1,1)
            z=zm1(i,1,1,1)
            u=vx (i,1,1,1)
            v=vy (i,1,1,1)
            w=vz (i,1,1,1)
            b=bm1(i,1,1,1)

            argx = x*2*pi*kx/xlen
            argy = y*2*pi*ky/ylen
            argz = z*2*pi*kz/zlen

            cx = cos(argx)
            cy = cos(argy)
            cz = cos(argz)
            sx = sin(argx)
            sy = sin(argy)
            sz = sin(argz)
            cs(1) = sx*sy*sz
            cs(2) = sx*sy*cz
            cs(3) = sx*cy*sz
            cs(4) = sx*cy*cz
            cs(5) = cx*sy*sz
            cs(6) = cx*sy*cz
            cs(7) = cx*cy*sz
            cs(8) = cx*cy*cz
c           u=cs(1)
c           v=0
c           w=0

            do l=1,8 ! Integrate
               ucs(kx,ky,kz,l) = ucs(kx,ky,kz,l) + cs(l)*u*b 
               vcs(kx,ky,kz,l) = vcs(kx,ky,kz,l) + cs(l)*v*b
               wcs(kx,ky,kz,l) = wcs(kx,ky,kz,l) + cs(l)*w*b
            enddo

         enddo
      enddo
      enddo
      enddo

      do kz=1,2  ! Find uhat = \int sin(kx 2pi x) ux
      do ky=1,2
      do kx=1,2

         do i=1,n

            x=xm1(i,1,1,1)
            y=ym1(i,1,1,1)
            z=zm1(i,1,1,1)
           u=vx (i,1,1,1)
           v=vy (i,1,1,1)
           w=vz (i,1,1,1)
            b=bm1(i,1,1,1)

            argx = x*2*pi*kx/xlen
            argy = y*2*pi*ky/ylen
            argz = z*2*pi*kz/zlen

            cx = cos(argx)
            cy = cos(argy)
            cz = cos(argz)
            sx = sin(argx)
            sy = sin(argy)
            sz = sin(argz)
            cs(1) = sx*sy*sz
            cs(2) = sx*sy*cz
            cs(3) = sx*cy*sz
            cs(4) = sx*cy*cz
            cs(5) = cx*sy*sz
            cs(6) = cx*sy*cz
            cs(7) = cx*cy*sz
            cs(8) = cx*cy*cz
c            u=cs(1)
c            v=0
c            w=0

            do l=1,8 ! Integrate
               uuu(kx,ky,kz,l) = uuu(kx,ky,kz,l) + cs(l)*cs(l)*b 
               vvv(kx,ky,kz,l) = vvv(kx,ky,kz,l) + cs(l)*cs(l)*b 
               www(kx,ky,kz,l) = www(kx,ky,kz,l) + cs(l)*cs(l)*b 
            enddo

         enddo
      enddo
      enddo
      enddo

      call gop(uuu,work,'+  ',64) ! Sum integrals across all processors
      call gop(vvv,work,'+  ',64) ! Sum integrals across all processors
      call gop(www,work,'+  ',64) ! Sum integrals across all processors

      call gop(ucs,work,'+  ',64) ! Sum integrals across all processors
      call gop(vcs,work,'+  ',64) ! Sum integrals across all processors
      call gop(wcs,work,'+  ',64) ! Sum integrals across all processors

      do kz=1,2  ! Find uhat = \int sin(kx 2pi x) ux
      do ky=1,2
      do kx=1,2
      do l=1,8 ! Integrate
      ucs(kx,ky,kz,l) = ucs(kx,ky,kz,l)/uuu(kx,ky,kz,l)
      vcs(kx,ky,kz,l) = vcs(kx,ky,kz,l)/vvv(kx,ky,kz,l)
      wcs(kx,ky,kz,l) = wcs(kx,ky,kz,l)/www(kx,ky,kz,l)
      enddo
      enddo
      enddo
      enddo


      if (nid.eq.0) write(6,*)'check energy'
      do kz=1,2  ! Find uhat = \int sin(kx 2pi x) ux
      do ky=1,2
      do kx=1,2
      do l=1,8 ! Integrate
         if (nid.eq.0) write(6,*)kx,ky,kz,l,ucs(kx,ky,kz,l),
     $   vcs(kx,ky,kz,l), wcs(kx,ky,kz,l)
      enddo
      enddo
      enddo
      enddo

      utot = 0
      do kz=1,2  ! Find uhat = \int sin(kx 2pi x) ux
      do ky=1,2
      do kx=1,2
      do l =1,8
         utot = utot + ucs(kx,ky,kz,l)**2
     $               + vcs(kx,ky,kz,l)**2
     $               + wcs(kx,ky,kz,l)**2
      enddo
      enddo
      enddo
      enddo


      if(nid.eq.0) write(*,*) 'utot=', utot

c      if (istep <10) then
c      utot = sqrt(utot)   ! YES? or NO?  (According to (19), no sqrt!)

c      else
c      utot = utot
c      endif

      utot_inv = 1./utot
      call cmult(ucs,utot_inv,64)
      call cmult(vcs,utot_inv,64)
      call cmult(wcs,utot_inv,64)

      do kz=1,2  ! Find uhat = \int sin(kx 2pi x) ux
      do ky=1,2
      do kx=1,2
      do l=1,8 ! Integrate
         if (nid.eq.0) write(6,*)kx,ky,kz,l,ucs(kx,ky,kz,l),
     $   vcs(kx,ky,kz,l), wcs(kx,ky,kz,l)
      enddo
      enddo
      enddo
      enddo

      call opzero(fxx,fyy,fzz)

      do kz=1,2  ! Find uhat = \int sin(kx 2pi x) ux
      do ky=1,2
      do kx=1,2

         do i=1,n

            x=xm1(i,1,1,1)
            y=ym1(i,1,1,1)
            z=zm1(i,1,1,1)

            argx = x*2*pi*kx/xlen
            argy = y*2*pi*ky/ylen
            argz = z*2*pi*kz/zlen


            cx = cos(argx)
            cy = cos(argy)
            cz = cos(argz)
            sx = sin(argx)
            sy = sin(argy)
            sz = sin(argz)
            cs(1) = sx*sy*sz
            cs(2) = sx*sy*cz
            cs(3) = sx*cy*sz
            cs(4) = sx*cy*cz
            cs(5) = cx*sy*sz
            cs(6) = cx*sy*cz
            cs(7) = cx*cy*sz
            cs(8) = cx*cy*cz

            do l=1,8
              fxx(i,1,1,1) = fxx(i,1,1,1) + cs(l)*ucs(kx,ky,kz,l)*eps
              fyy(i,1,1,1) = fyy(i,1,1,1) + cs(l)*vcs(kx,ky,kz,l)*eps
              fzz(i,1,1,1) = fzz(i,1,1,1) + cs(l)*wcs(kx,ky,kz,l)*eps
            enddo

         enddo
      enddo
      enddo
      enddo
      ifxyo=.true.
      call outpost(fxx,fyy,fzz,pr,t,'fff')
      call exitt0

      return
      end
c-----------------------------------------------------------------------
      subroutine my_diss
      include 'SIZE'
      include 'TOTAL'

      parameter (lt=lx1*ly1*lz1*lelt)
      common /myTKE1/dis1(lt)
      common /myTKE/ dufx(lt),dufy(lt),dufz(lt)
      common /myTKE/ dvfx(lt),dvfy(lt),dvfz(lt)
      common /myTKE/ dwfx(lt),dwfy(lt),dwfz(lt)
      common /myTKE/ dufx2(lt),dufy2(lt),dufz2(lt)
      common /myTKE/ dvfx2(lt),dvfy2(lt),dvfz2(lt)
      common /myTKE/ dwfx2(lt),dwfy2(lt),dwfz2(lt)

      real negflag, Re1, dumhalf,tw1
      n = lx1*ly1*lz1*nelt
      n2= lx2*ly2*lz2*nelt

      negflag=-1.0
      dumhalf=0.5
      tw1 = 2.0
      Re1=param(2)
       if (nid.eq.0) then
      write(6,*) '1 over Reynolds number=', Re1
       endif
    
      call rzero (dis1,n)

      call rzero (dufx,n)
      call rzero (dufy,n)
      call rzero (dufz,n)
      call rzero (dvfx,n)
      call rzero (dvfy,n)
      call rzero (dvfz,n)
      call rzero (dwfx,n)
      call rzero (dwfy,n)
      call rzero (dwfz,n)
      call rzero (dufx2,n)
      call rzero (dufy2,n)
      call rzero (dufz2,n)
      call rzero (dvfx2,n)
      call rzero (dvfy2,n)
      call rzero (dvfz2,n)
      call rzero (dwfx2,n)
      call rzero (dwfy2,n)
      call rzero (dwfz2,n)


      call gradm1(dufx,dufy,dufz,vx)
      call gradm1(dvfx,dvfy,dvfz,vy)
      call gradm1(dwfx,dwfy,dwfz,vz)

      call col3(dufx2,dufx,dufx,n)
      call col3(dufy2,dufy,dufy,n)
      call col3(dufz2,dufz,dufz,n)
      call col3(dvfx2,dvfx,dvfx,n)
      call col3(dvfy2,dvfy,dvfy,n)
      call col3(dvfz2,dvfz,dvfz,n)
      call col3(dwfx2,dwfx,dwfx,n)
      call col3(dwfy2,dwfy,dwfy,n)
      call col3(dwfz2,dwfz,dwfz,n)

      ! TKE Dissipation
      call add2(dis1,dufx2,n)
      call add2(dis1,dufy2,n)
      call add2(dis1,dufz2,n)
      call add2(dis1,dvfx2,n)
      call add2(dis1,dvfy2,n)
      call add2(dis1,dvfz2,n)
      call add2(dis1,dwfx2,n)
      call add2(dis1,dwfy2,n)
      call add2(dis1,dwfz2,n)
      call cmult(dis1,Re1,n)
      call cmult(dis1,negflag,n)

      call outpost(dis1,dis1,dis1,dis1, t,'dis')
      return
      end



c-----------------------------------------------------------------------
